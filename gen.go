// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.1 DO NOT EDIT.
package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Api_keyScopes = "api_key.Scopes"
	Oauth2Scopes  = "oauth2.Scopes"
)

// APIError defines model for APIError.
type APIError struct {
	Error  string `json:"error"`
	Status int32  `json:"status"`
}

// ArticleCreate defines model for ArticleCreate.
type ArticleCreate struct {
	Article *struct {

		// The body of the article.
		//
		// It can contain an optional front matter. For example
		//
		// ```markdown
		// ---
		// title: Hello, World!
		// published: true
		// tags: discuss, help
		// date: 20190701T10:00Z
		// series: Hello series
		// canonical_url: https://example.com/blog/hello
		// cover_image: article_published_cover_image
		// ---
		// ```
		//
		// `date`, `series` and `canonical_url` are optional.
		// `date` is the publication date-time
		// `series` is the name of the series the article belongs to
		// `canonical_url` is the canonical URL of the article
		// `cover_image` is the main image of the article
		//
		// *If the markdown contains a front matter, it will take precedence
		// on the equivalent params given in the payload.*
		BodyMarkdown *string `json:"body_markdown,omitempty"`
		CanonicalUrl *string `json:"canonical_url,omitempty"`
		Description  *string `json:"description,omitempty"`
		MainImage    *string `json:"main_image,omitempty"`

		// Only users belonging to an organization can assign the article to it
		OrganizationId *int32 `json:"organization_id,omitempty"`

		// True to create a published article, false otherwise. Defaults to false
		Published *bool `json:"published,omitempty"`

		// Article series name.
		//
		// All articles belonging to the same series need to have the same name
		// in this parameter.
		Series *string   `json:"series,omitempty"`
		Tags   *[]string `json:"tags,omitempty"`
		Title  *string   `json:"title,omitempty"`
	} `json:"article,omitempty"`
}

// Flare tag of the article
type ArticleFlareTag struct {

	// Background color (hexadecimal)
	BgColorHex *string `json:"bg_color_hex,omitempty"`
	Name       *string `json:"name,omitempty"`

	// Text color (hexadecimal)
	TextColorHex *string `json:"text_color_hex,omitempty"`
}

// ArticleIndex defines model for ArticleIndex.
type ArticleIndex struct {
	CanonicalUrl  string     `json:"canonical_url"`
	CommentsCount int32      `json:"comments_count"`
	CoverImage    *string    `json:"cover_image"`
	CreatedAt     time.Time  `json:"created_at"`
	CrosspostedAt *time.Time `json:"crossposted_at"`
	Description   string     `json:"description"`
	EditedAt      *time.Time `json:"edited_at"`

	// Flare tag of the article
	FlareTag      *ArticleFlareTag `json:"flare_tag,omitempty"`
	Id            int32            `json:"id"`
	LastCommentAt time.Time        `json:"last_comment_at"`

	// The organization the resource belongs to
	Organization           *SharedOrganization `json:"organization,omitempty"`
	Path                   string              `json:"path"`
	PositiveReactionsCount int32               `json:"positive_reactions_count"`
	PublicReactionsCount   int32               `json:"public_reactions_count"`
	PublishedAt            time.Time           `json:"published_at"`

	// Crossposting or published date time
	PublishedTimestamp  time.Time `json:"published_timestamp"`
	ReadablePublishDate string    `json:"readable_publish_date"`

	// Reading time, in minutes
	ReadingTimeMinutes int32    `json:"reading_time_minutes"`
	Slug               string   `json:"slug"`
	SocialImage        string   `json:"social_image"`
	TagList            []string `json:"tag_list"`
	Tags               string   `json:"tags"`
	Title              string   `json:"title"`
	TypeOf             string   `json:"type_of"`
	Url                string   `json:"url"`

	// The resource creator
	User SharedUser `json:"user"`
}

// ArticleMe defines model for ArticleMe.
type ArticleMe struct {

	// The body of the article in Markdown format
	BodyMarkdown  string  `json:"body_markdown"`
	CanonicalUrl  string  `json:"canonical_url"`
	CommentsCount int32   `json:"comments_count"`
	CoverImage    *string `json:"cover_image"`
	Description   string  `json:"description"`

	// Flare tag of the article
	FlareTag *ArticleFlareTag `json:"flare_tag,omitempty"`
	Id       int32            `json:"id"`

	// The organization the resource belongs to
	Organization           *SharedOrganization `json:"organization,omitempty"`
	PageViewsCount         int32               `json:"page_views_count"`
	Path                   string              `json:"path"`
	PositiveReactionsCount int32               `json:"positive_reactions_count"`
	PublicReactionsCount   int32               `json:"public_reactions_count"`
	Published              bool                `json:"published"`
	// PublishedAt            time.Time           `json:"published_at"`

	// Crossposting or published date time
	// PublishedTimestamp time.Time `json:"published_timestamp"`

	// Reading time, in minutes
	ReadingTimeMinutes int32    `json:"reading_time_minutes"`
	Slug               string   `json:"slug"`
	TagList            []string `json:"tag_list"`
	Title              string   `json:"title"`
	TypeOf             string   `json:"type_of"`
	Url                string   `json:"url"`

	// The resource creator
	User SharedUser `json:"user"`
}

// ArticleShow defines model for ArticleShow.
type ArticleShow struct {
	BodyHtml      string     `json:"body_html"`
	BodyMarkdown  string     `json:"body_markdown"`
	CanonicalUrl  string     `json:"canonical_url"`
	CommentsCount int32      `json:"comments_count"`
	CoverImage    *string    `json:"cover_image"`
	CreatedAt     time.Time  `json:"created_at"`
	CrosspostedAt *time.Time `json:"crossposted_at"`
	Description   string     `json:"description"`
	EditedAt      *time.Time `json:"edited_at"`

	// Flare tag of the article
	FlareTag      *ArticleFlareTag `json:"flare_tag,omitempty"`
	Id            int32            `json:"id"`
	LastCommentAt time.Time        `json:"last_comment_at"`

	// The organization the resource belongs to
	Organization           *SharedOrganization `json:"organization,omitempty"`
	Path                   string              `json:"path"`
	PositiveReactionsCount int32               `json:"positive_reactions_count"`
	PublicReactionsCount   int32               `json:"public_reactions_count"`
	PublishedAt            time.Time           `json:"published_at"`

	// Crossposting or published date time
	PublishedTimestamp  time.Time `json:"published_timestamp"`
	ReadablePublishDate string    `json:"readable_publish_date"`

	// Reading time, in minutes
	ReadingTimeMinutes int32    `json:"reading_time_minutes"`
	Slug               string   `json:"slug"`
	SocialImage        string   `json:"social_image"`
	TagList            string   `json:"tag_list"`
	Tags               []string `json:"tags"`
	Title              string   `json:"title"`
	TypeOf             string   `json:"type_of"`
	Url                string   `json:"url"`

	// The resource creator
	User SharedUser `json:"user"`
}

// ArticleUpdate defines model for ArticleUpdate.
type ArticleUpdate struct {
	Article *struct {

		// The body of the article.
		//
		// It can contain an optional front matter. For example
		//
		// ```markdown
		// ---
		// title: Hello, World!
		// published: true
		// tags: discuss, help
		// date: 20190701T10:00Z
		// series: Hello series
		// canonical_url: https://example.com/blog/hello
		// cover_image: article_published_cover_image
		// ---
		// ```
		//
		// `date`, `series` and `canonical_url` are optional.
		// `date` is the publication date-time
		// `series` is the name of the series the article belongs to
		// `canonical_url` is the canonical URL of the article
		// `cover_image` is the main image of the article
		//
		// *If the markdown contains a front matter, it will take precedence
		// on the equivalent params given in the payload.*
		BodyMarkdown *string `json:"body_markdown,omitempty"`
		CanonicalUrl *string `json:"canonical_url,omitempty"`
		Description  *string `json:"description,omitempty"`
		MainImage    *string `json:"main_image,omitempty"`

		// Only users belonging to an organization can assign the article to it
		OrganizationId *int32 `json:"organization_id,omitempty"`

		// True to create a published article, false otherwise. Defaults to false
		Published *bool `json:"published,omitempty"`

		// Article series name.
		//
		// All articles belonging to the same series need to have the same name
		// in this parameter.
		//
		// To remove an article from a series, the `null` value can be used.
		Series *string   `json:"series,omitempty"`
		Tags   *[]string `json:"tags,omitempty"`
		Title  *string   `json:"title,omitempty"`
	} `json:"article,omitempty"`
}

// ArticleVideo defines model for ArticleVideo.
type ArticleVideo struct {

	// The preview image of the video
	CloudinaryVideoUrl string `json:"cloudinary_video_url"`
	Id                 int32  `json:"id"`
	Path               string `json:"path"`
	Title              string `json:"title"`
	TypeOf             string `json:"type_of"`
	User               struct {

		// The user's name
		Name *string `json:"name,omitempty"`
	} `json:"user"`
	UserId int32 `json:"user_id"`

	// The duration of the video.
	//
	// If the video duration is below 1 hour, the format will be `mm:ss`,
	// if it's 1 hour or above the format will be `h:mm:ss`.
	VideoDurationInMinutes string `json:"video_duration_in_minutes"`
	VideoSourceUrl         string `json:"video_source_url"`
}

// Comment defines model for Comment.
type Comment struct {

	// HTML formatted comment
	BodyHtml  string    `json:"body_html"`
	Children  []Comment `json:"children"`
	CreatedAt time.Time `json:"created_at"`
	IdCode    string    `json:"id_code"`
	TypeOf    string    `json:"type_of"`

	// The resource creator
	User SharedUser `json:"user"`
}

// The organization the resource belongs to
type SharedOrganization struct {
	Name *string `json:"name,omitempty"`

	// Profile image (640x640)
	ProfileImage *string `json:"profile_image,omitempty"`

	// Profile image (90x90)
	ProfileImage90 *string `json:"profile_image_90,omitempty"`
	Slug           *string `json:"slug,omitempty"`
	Username       *string `json:"username,omitempty"`
}

// The resource creator
type SharedUser struct {
	GithubUsername *string `json:"github_username"`
	Name           *string `json:"name,omitempty"`

	// Profile image (640x640)
	ProfileImage *string `json:"profile_image,omitempty"`

	// Profile image (90x90)
	ProfileImage90  *string `json:"profile_image_90,omitempty"`
	TwitterUsername *string `json:"twitter_username"`
	Username        *string `json:"username,omitempty"`
	WebsiteUrl      *string `json:"website_url"`
}

// PageParam defines model for pageParam.
type PageParam int32

// PerPageParam24to1000 defines model for perPageParam24to1000.
type PerPageParam24to1000 int32

// PerPageParam30to1000 defines model for perPageParam30to1000.
type PerPageParam30to1000 int32

// GetArticlesParams defines parameters for GetArticles.
type GetArticlesParams struct {

	// Pagination page.
	Page *PageParam `json:"page,omitempty"`

	// Page size (the number of items to return per page).
	PerPage *PerPageParam30to1000 `json:"per_page,omitempty"`

	// Using this parameter will retrieve articles that contain the
	// requested tag.
	//
	// Articles will be ordered by descending popularity.
	//
	// This parameter can be used in conjuction with `top`.
	Tag *string `json:"tag,omitempty"`

	// Using this parameter will retrieve articles with any of the comma-separated tags.
	//
	// Articles will be ordered by descending popularity.
	Tags *string `json:"tags,omitempty"`

	// Using this parameter will retrieve articles that do _not_ contain _any_ of comma-separated tags.
	//
	// Articles will be ordered by descending popularity.
	TagsExclude *string `json:"tags_exclude,omitempty"`

	// Using this parameter will retrieve articles belonging
	// to a User or Organization ordered by descending publication date.
	//
	// If `state=all` the number of items returned will be `1000` instead of the default `30`.
	//
	// This parameter can be used in conjuction with `state`.
	Username *string `json:"username,omitempty"`

	// Using this parameter will allow the client to check which articles are fresh or rising.
	//
	// If `state=fresh` the server will return fresh articles.
	// If `state=rising` the server will return rising articles.
	//
	// This param can be used in conjuction with `username`, only if set to `all`.
	State *GetArticlesParamsState `json:"state,omitempty"`

	// Using this parameter will allow the client to return the most popular articles
	// in the last `N` days.
	//
	// `top` indicates the number of days since publication of the articles
	// returned.
	//
	// This param can be used in conjuction with `tag`.
	Top *int32 `json:"top,omitempty"`

	// Adding this will allow the client to return the list of articles
	// belonging to the requested collection, ordered by ascending
	// publication date.
	CollectionId *int32 `json:"collection_id,omitempty"`
}

// GetArticlesParamsState defines parameters for GetArticles.
type GetArticlesParamsState string

// CreateArticleJSONBody defines parameters for CreateArticle.
type CreateArticleJSONBody ArticleCreate

// GetLatestArticlesParams defines parameters for GetLatestArticles.
type GetLatestArticlesParams struct {

	// Pagination page.
	Page *PageParam `json:"page,omitempty"`

	// Page size (the number of items to return per page).
	PerPage *PerPageParam30to1000 `json:"per_page,omitempty"`
}

// GetUserArticlesParams defines parameters for GetUserArticles.
type GetUserArticlesParams struct {

	// Pagination page.
	Page *PageParam `json:"page,omitempty"`

	// Page size (the number of items to return per page).
	PerPage *PerPageParam30to1000 `json:"per_page,omitempty"`
}

// GetUserAllArticlesParams defines parameters for GetUserAllArticles.
type GetUserAllArticlesParams struct {

	// Pagination page.
	Page *PageParam `json:"page,omitempty"`

	// Page size (the number of items to return per page).
	PerPage *PerPageParam30to1000 `json:"per_page,omitempty"`
}

// GetUserPublishedArticlesParams defines parameters for GetUserPublishedArticles.
type GetUserPublishedArticlesParams struct {

	// Pagination page.
	Page *PageParam `json:"page,omitempty"`

	// Page size (the number of items to return per page).
	PerPage *PerPageParam30to1000 `json:"per_page,omitempty"`
}

// GetUserUnpublishedArticlesParams defines parameters for GetUserUnpublishedArticles.
type GetUserUnpublishedArticlesParams struct {

	// Pagination page.
	Page *PageParam `json:"page,omitempty"`

	// Page size (the number of items to return per page).
	PerPage *PerPageParam30to1000 `json:"per_page,omitempty"`
}

// UpdateArticleJSONBody defines parameters for UpdateArticle.
type UpdateArticleJSONBody ArticleUpdate

// GetArticlesWithVideoParams defines parameters for GetArticlesWithVideo.
type GetArticlesWithVideoParams struct {

	// Pagination page.
	Page *PageParam `json:"page,omitempty"`

	// Page size (the number of items to return per page).
	PerPage *PerPageParam24to1000 `json:"per_page,omitempty"`
}

// CreateArticleJSONRequestBody defines body for CreateArticle for application/json ContentType.
type CreateArticleJSONRequestBody CreateArticleJSONBody

// UpdateArticleJSONRequestBody defines body for UpdateArticle for application/json ContentType.
type UpdateArticleJSONRequestBody UpdateArticleJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetArticles request
	GetArticles(ctx context.Context, params *GetArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateArticle request  with any body
	CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestArticles request
	GetLatestArticles(ctx context.Context, params *GetLatestArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserArticles request
	GetUserArticles(ctx context.Context, params *GetUserArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAllArticles request
	GetUserAllArticles(ctx context.Context, params *GetUserAllArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserPublishedArticles request
	GetUserPublishedArticles(ctx context.Context, params *GetUserPublishedArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserUnpublishedArticles request
	GetUserUnpublishedArticles(ctx context.Context, params *GetUserUnpublishedArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticleById request
	GetArticleById(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateArticle request  with any body
	UpdateArticleWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateArticle(ctx context.Context, id int32, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticleByPath request
	GetArticleByPath(ctx context.Context, username string, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticlesWithVideo request
	GetArticlesWithVideo(ctx context.Context, params *GetArticlesWithVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetArticles(ctx context.Context, params *GetArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestArticles(ctx context.Context, params *GetLatestArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserArticles(ctx context.Context, params *GetUserArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAllArticles(ctx context.Context, params *GetUserAllArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAllArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserPublishedArticles(ctx context.Context, params *GetUserPublishedArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserPublishedArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserUnpublishedArticles(ctx context.Context, params *GetUserUnpublishedArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserUnpublishedArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticleById(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticleByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticleWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticle(ctx context.Context, id int32, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticleByPath(ctx context.Context, username string, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticleByPathRequest(c.Server, username, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticlesWithVideo(ctx context.Context, params *GetArticlesWithVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticlesWithVideoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetArticlesRequest generates requests for GetArticles
func NewGetArticlesRequest(server string, params *GetArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.PerPage != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.Tag != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.Tags != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.TagsExclude != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags_exclude", runtime.ParamLocationQuery, *params.TagsExclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.Username != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.State != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.Top != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "top", runtime.ParamLocationQuery, *params.Top); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.CollectionId != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collection_id", runtime.ParamLocationQuery, *params.CollectionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateArticleRequest calls the generic CreateArticle builder with application/json body
func NewCreateArticleRequest(server string, body CreateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateArticleRequestWithBody generates requests for CreateArticle with any type of body
func NewCreateArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLatestArticlesRequest generates requests for GetLatestArticles
func NewGetLatestArticlesRequest(server string, params *GetLatestArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/latest")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.PerPage != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserArticlesRequest generates requests for GetUserArticles
func NewGetUserArticlesRequest(server string, params *GetUserArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/me")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.PerPage != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserAllArticlesRequest generates requests for GetUserAllArticles
func NewGetUserAllArticlesRequest(server string, params *GetUserAllArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/me/all")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.PerPage != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserPublishedArticlesRequest generates requests for GetUserPublishedArticles
func NewGetUserPublishedArticlesRequest(server string, params *GetUserPublishedArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/me/published")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.PerPage != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserUnpublishedArticlesRequest generates requests for GetUserUnpublishedArticles
func NewGetUserUnpublishedArticlesRequest(server string, params *GetUserUnpublishedArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/me/unpublished")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.PerPage != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArticleByIdRequest generates requests for GetArticleById
func NewGetArticleByIdRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateArticleRequest calls the generic UpdateArticle builder with application/json body
func NewUpdateArticleRequest(server string, id int32, body UpdateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateArticleRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateArticleRequestWithBody generates requests for UpdateArticle with any type of body
func NewUpdateArticleRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArticleByPathRequest generates requests for GetArticleByPath
func NewGetArticleByPathRequest(server string, username string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArticlesWithVideoRequest generates requests for GetArticlesWithVideo
func NewGetArticlesWithVideoRequest(server string, params *GetArticlesWithVideoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.PerPage != nil {
		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetArticles request
	GetArticlesWithResponse(ctx context.Context, params *GetArticlesParams, reqEditors ...RequestEditorFn) (*GetArticlesResponse, error)

	// CreateArticle request  with any body
	CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error)

	CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error)

	// GetLatestArticles request
	GetLatestArticlesWithResponse(ctx context.Context, params *GetLatestArticlesParams, reqEditors ...RequestEditorFn) (*GetLatestArticlesResponse, error)

	// GetUserArticles request
	GetUserArticlesWithResponse(ctx context.Context, params *GetUserArticlesParams, reqEditors ...RequestEditorFn) (*GetUserArticlesResponse, error)

	// GetUserAllArticles request
	GetUserAllArticlesWithResponse(ctx context.Context, params *GetUserAllArticlesParams, reqEditors ...RequestEditorFn) (*GetUserAllArticlesResponse, error)

	// GetUserPublishedArticles request
	GetUserPublishedArticlesWithResponse(ctx context.Context, params *GetUserPublishedArticlesParams, reqEditors ...RequestEditorFn) (*GetUserPublishedArticlesResponse, error)

	// GetUserUnpublishedArticles request
	GetUserUnpublishedArticlesWithResponse(ctx context.Context, params *GetUserUnpublishedArticlesParams, reqEditors ...RequestEditorFn) (*GetUserUnpublishedArticlesResponse, error)

	// GetArticleById request
	GetArticleByIdWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*GetArticleByIdResponse, error)

	// UpdateArticle request  with any body
	UpdateArticleWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error)

	UpdateArticleWithResponse(ctx context.Context, id int32, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error)

	// GetArticleByPath request
	GetArticleByPathWithResponse(ctx context.Context, username string, slug string, reqEditors ...RequestEditorFn) (*GetArticleByPathResponse, error)

	// GetArticlesWithVideo request
	GetArticlesWithVideoWithResponse(ctx context.Context, params *GetArticlesWithVideoParams, reqEditors ...RequestEditorFn) (*GetArticlesWithVideoResponse, error)
}

type GetArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArticleIndex
}

// Status returns HTTPResponse.Status
func (r GetArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ArticleShow
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON422      *APIError
	JSON429      *APIError
}

// Status returns HTTPResponse.Status
func (r CreateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArticleIndex
}

// Status returns HTTPResponse.Status
func (r GetLatestArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArticleMe
	JSON401      *APIError
}

// Status returns HTTPResponse.Status
func (r GetUserArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAllArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArticleMe
	JSON401      *APIError
}

// Status returns HTTPResponse.Status
func (r GetUserAllArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAllArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserPublishedArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArticleMe
	JSON401      *APIError
}

// Status returns HTTPResponse.Status
func (r GetUserPublishedArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserPublishedArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserUnpublishedArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArticleMe
	JSON401      *APIError
}

// Status returns HTTPResponse.Status
func (r GetUserUnpublishedArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserUnpublishedArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticleShow
	JSON404      *APIError
}

// Status returns HTTPResponse.Status
func (r GetArticleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticleShow
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON422      *APIError
	JSON429      *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticleByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticleShow
	JSON404      *APIError
}

// Status returns HTTPResponse.Status
func (r GetArticleByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticleByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticlesWithVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArticleVideo
}

// Status returns HTTPResponse.Status
func (r GetArticlesWithVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticlesWithVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetArticlesWithResponse request returning *GetArticlesResponse
func (c *ClientWithResponses) GetArticlesWithResponse(ctx context.Context, params *GetArticlesParams, reqEditors ...RequestEditorFn) (*GetArticlesResponse, error) {
	rsp, err := c.GetArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticlesResponse(rsp)
}

// CreateArticleWithBodyWithResponse request with arbitrary body returning *CreateArticleResponse
func (c *ClientWithResponses) CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

func (c *ClientWithResponses) CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

// GetLatestArticlesWithResponse request returning *GetLatestArticlesResponse
func (c *ClientWithResponses) GetLatestArticlesWithResponse(ctx context.Context, params *GetLatestArticlesParams, reqEditors ...RequestEditorFn) (*GetLatestArticlesResponse, error) {
	rsp, err := c.GetLatestArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestArticlesResponse(rsp)
}

// GetUserArticlesWithResponse request returning *GetUserArticlesResponse
func (c *ClientWithResponses) GetUserArticlesWithResponse(ctx context.Context, params *GetUserArticlesParams, reqEditors ...RequestEditorFn) (*GetUserArticlesResponse, error) {
	rsp, err := c.GetUserArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserArticlesResponse(rsp)
}

// GetUserAllArticlesWithResponse request returning *GetUserAllArticlesResponse
func (c *ClientWithResponses) GetUserAllArticlesWithResponse(ctx context.Context, params *GetUserAllArticlesParams, reqEditors ...RequestEditorFn) (*GetUserAllArticlesResponse, error) {
	rsp, err := c.GetUserAllArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAllArticlesResponse(rsp)
}

// GetUserPublishedArticlesWithResponse request returning *GetUserPublishedArticlesResponse
func (c *ClientWithResponses) GetUserPublishedArticlesWithResponse(ctx context.Context, params *GetUserPublishedArticlesParams, reqEditors ...RequestEditorFn) (*GetUserPublishedArticlesResponse, error) {
	rsp, err := c.GetUserPublishedArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserPublishedArticlesResponse(rsp)
}

// GetUserUnpublishedArticlesWithResponse request returning *GetUserUnpublishedArticlesResponse
func (c *ClientWithResponses) GetUserUnpublishedArticlesWithResponse(ctx context.Context, params *GetUserUnpublishedArticlesParams, reqEditors ...RequestEditorFn) (*GetUserUnpublishedArticlesResponse, error) {
	rsp, err := c.GetUserUnpublishedArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserUnpublishedArticlesResponse(rsp)
}

// GetArticleByIdWithResponse request returning *GetArticleByIdResponse
func (c *ClientWithResponses) GetArticleByIdWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*GetArticleByIdResponse, error) {
	rsp, err := c.GetArticleById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticleByIdResponse(rsp)
}

// UpdateArticleWithBodyWithResponse request with arbitrary body returning *UpdateArticleResponse
func (c *ClientWithResponses) UpdateArticleWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticleWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

func (c *ClientWithResponses) UpdateArticleWithResponse(ctx context.Context, id int32, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticle(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

// GetArticleByPathWithResponse request returning *GetArticleByPathResponse
func (c *ClientWithResponses) GetArticleByPathWithResponse(ctx context.Context, username string, slug string, reqEditors ...RequestEditorFn) (*GetArticleByPathResponse, error) {
	rsp, err := c.GetArticleByPath(ctx, username, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticleByPathResponse(rsp)
}

// GetArticlesWithVideoWithResponse request returning *GetArticlesWithVideoResponse
func (c *ClientWithResponses) GetArticlesWithVideoWithResponse(ctx context.Context, params *GetArticlesWithVideoParams, reqEditors ...RequestEditorFn) (*GetArticlesWithVideoResponse, error) {
	rsp, err := c.GetArticlesWithVideo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticlesWithVideoResponse(rsp)
}

// ParseGetArticlesResponse parses an HTTP response from a GetArticlesWithResponse call
func ParseGetArticlesResponse(rsp *http.Response) (*GetArticlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArticleIndex
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ParseCreateArticleResponse parses an HTTP response from a CreateArticleWithResponse call
func ParseCreateArticleResponse(rsp *http.Response) (*CreateArticleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ArticleShow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetLatestArticlesResponse parses an HTTP response from a GetLatestArticlesWithResponse call
func ParseGetLatestArticlesResponse(rsp *http.Response) (*GetLatestArticlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLatestArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArticleIndex
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ParseGetUserArticlesResponse parses an HTTP response from a GetUserArticlesWithResponse call
func ParseGetUserArticlesResponse(rsp *http.Response) (*GetUserArticlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArticleMe
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserAllArticlesResponse parses an HTTP response from a GetUserAllArticlesWithResponse call
func ParseGetUserAllArticlesResponse(rsp *http.Response) (*GetUserAllArticlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserAllArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArticleMe
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserPublishedArticlesResponse parses an HTTP response from a GetUserPublishedArticlesWithResponse call
func ParseGetUserPublishedArticlesResponse(rsp *http.Response) (*GetUserPublishedArticlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserPublishedArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArticleMe
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserUnpublishedArticlesResponse parses an HTTP response from a GetUserUnpublishedArticlesWithResponse call
func ParseGetUserUnpublishedArticlesResponse(rsp *http.Response) (*GetUserUnpublishedArticlesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserUnpublishedArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArticleMe
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetArticleByIdResponse parses an HTTP response from a GetArticleByIdWithResponse call
func ParseGetArticleByIdResponse(rsp *http.Response) (*GetArticleByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetArticleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticleShow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateArticleResponse parses an HTTP response from a UpdateArticleWithResponse call
func ParseUpdateArticleResponse(rsp *http.Response) (*UpdateArticleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticleShow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetArticleByPathResponse parses an HTTP response from a GetArticleByPathWithResponse call
func ParseGetArticleByPathResponse(rsp *http.Response) (*GetArticleByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetArticleByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticleShow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetArticlesWithVideoResponse parses an HTTP response from a GetArticlesWithVideoWithResponse call
func ParseGetArticlesWithVideoResponse(rsp *http.Response) (*GetArticlesWithVideoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetArticlesWithVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArticleVideo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Published articles
	// (GET /articles)
	GetArticles(ctx echo.Context, params GetArticlesParams) error
	// Create a new article
	// (POST /articles)
	CreateArticle(ctx echo.Context) error
	// Published articles sorted by publish date
	// (GET /articles/latest)
	GetLatestArticles(ctx echo.Context, params GetLatestArticlesParams) error
	// User's articles
	// (GET /articles/me)
	GetUserArticles(ctx echo.Context, params GetUserArticlesParams) error
	// User's all articles
	// (GET /articles/me/all)
	GetUserAllArticles(ctx echo.Context, params GetUserAllArticlesParams) error
	// User's published articles
	// (GET /articles/me/published)
	GetUserPublishedArticles(ctx echo.Context, params GetUserPublishedArticlesParams) error
	// User's unpublished articles
	// (GET /articles/me/unpublished)
	GetUserUnpublishedArticles(ctx echo.Context, params GetUserUnpublishedArticlesParams) error
	// A published article by ID
	// (GET /articles/{id})
	GetArticleById(ctx echo.Context, id int32) error
	// Update an article
	// (PUT /articles/{id})
	UpdateArticle(ctx echo.Context, id int32) error
	// A published article by path
	// (GET /articles/{username}/{slug})
	GetArticleByPath(ctx echo.Context, username string, slug string) error
	// Articles with a video
	// (GET /videos)
	GetArticlesWithVideo(ctx echo.Context, params GetArticlesWithVideoParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticles(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", true, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "tags_exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "tags_exclude", ctx.QueryParams(), &params.TagsExclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags_exclude: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "top" -------------

	err = runtime.BindQueryParameter("form", true, false, "top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter top: %s", err))
	}

	// ------------- Optional query parameter "collection_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "collection_id", ctx.QueryParams(), &params.CollectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArticles(ctx, params)
	return err
}

// CreateArticle converts echo context to params.
func (w *ServerInterfaceWrapper) CreateArticle(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	ctx.Set(Oauth2Scopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateArticle(ctx)
	return err
}

// GetLatestArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestArticles(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLatestArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLatestArticles(ctx, params)
	return err
}

// GetUserArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserArticles(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	ctx.Set(Oauth2Scopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserArticles(ctx, params)
	return err
}

// GetUserAllArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserAllArticles(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	ctx.Set(Oauth2Scopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserAllArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserAllArticles(ctx, params)
	return err
}

// GetUserPublishedArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserPublishedArticles(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	ctx.Set(Oauth2Scopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserPublishedArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserPublishedArticles(ctx, params)
	return err
}

// GetUserUnpublishedArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserUnpublishedArticles(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	ctx.Set(Oauth2Scopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserUnpublishedArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserUnpublishedArticles(ctx, params)
	return err
}

// GetArticleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int32

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArticleById(ctx, id)
	return err
}

// UpdateArticle converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateArticle(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int32

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	ctx.Set(Oauth2Scopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateArticle(ctx, id)
	return err
}

// GetArticleByPath converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticleByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, ctx.Param("username"), &username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArticleByPath(ctx, username, slug)
	return err
}

// GetArticlesWithVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticlesWithVideo(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesWithVideoParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArticlesWithVideo(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/articles", wrapper.GetArticles)
	router.POST(baseURL+"/articles", wrapper.CreateArticle)
	router.GET(baseURL+"/articles/latest", wrapper.GetLatestArticles)
	router.GET(baseURL+"/articles/me", wrapper.GetUserArticles)
	router.GET(baseURL+"/articles/me/all", wrapper.GetUserAllArticles)
	router.GET(baseURL+"/articles/me/published", wrapper.GetUserPublishedArticles)
	router.GET(baseURL+"/articles/me/unpublished", wrapper.GetUserUnpublishedArticles)
	router.GET(baseURL+"/articles/:id", wrapper.GetArticleById)
	router.PUT(baseURL+"/articles/:id", wrapper.UpdateArticle)
	router.GET(baseURL+"/articles/:username/:slug", wrapper.GetArticleByPath)
	router.GET(baseURL+"/videos", wrapper.GetArticlesWithVideo)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
